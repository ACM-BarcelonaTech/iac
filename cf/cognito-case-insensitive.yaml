AWSTemplateFormatVersion: "2010-09-09"
Description: Set up case insensitive Cognito resources for Biomage SCP [managed by github.com/hms-dbmi-cellenics/iac]

Parameters:
  Environment:
    Type: String
    Default: development
    AllowedValues:
      - development
      - staging
      - production
    Description: The environment for which the buckets need to be created.

Conditions:
  isProd: !Equals [!Ref Environment, "production"]

Outputs:
  UserPoolId:
    Value: !Ref UserPool
    Export:
      Name: !Sub 'biomage-user-pool-case-insensitive-${Environment}::UserPoolId'
  UserPoolProviderName:
    Description: Address to use to connect to Primary Cluster endpoint
    Value: !GetAtt UserPool.ProviderName
    Export:
      Name: !Sub 'biomage-user-pool-case-insensitive-${Environment}::UserPoolProviderName'
  UIRoleArn:
    Description: ARN of the UI role
    Value: !GetAtt UIRole.Arn
    Export:
      Name: !Sub 'biomage-user-pool-case-insensitive-${Environment}::UIRoleArn'

Resources:
  UIRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: !Sub "biomage-user-pool-case-insensitive-ui-auth-user-role-${Environment}"
      AssumeRolePolicyDocument: |-
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "",
              "Effect": "Allow",
              "Principal": {
                "Federated": "cognito-identity.amazonaws.com"
              },
              "Action": "sts:AssumeRoleWithWebIdentity",
              "Condition": {
                "ForAnyValue:StringLike": {
                  "cognito-identity.amazonaws.com:amr": "authenticated"
                }
              }
            }
          ]
        }
      Path: /
      Policies:
        - PolicyName: !Sub "can-upload-object-to-destination-bucket-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "s3:PutObject"
                  - "s3:ListMultipartUploadParts"
                  - "s3:AbortMultipartUpload"
                  - "s3:ListBucketMultipartUploads"
                Resource:
                  - !Sub "arn:aws:s3:::biomage-originals-${Environment}/*"

        - PolicyName: !Sub "can-get-from-work-response-bucket-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "s3:GetObject"
                  - "s3:GetObjectTagging"
                Resource:
                  - !Sub "arn:aws:s3:::worker-results-${Environment}/*"
                Condition:
                  StringEquals:
                    "s3:ExistingObjectTag/public": "true"

        - PolicyName: !Sub "can-list-objects-in-bucket-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "s3:ListBucket"
                Resource:
                  - !Sub "arn:aws:s3:::biomage-originals-${Environment}"
        - PolicyName: !Sub "can-get-public-datasets-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "s3:GetObject"
                  - "s3:GetObjectTagging"
                Resource:
                  - !Sub "arn:aws:s3:::biomage-public-datasets-${Environment}/*"
        - PolicyName: !Sub "can-execute-lambda-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "lambda:InvokeFunction"
                Resource:
                  Fn::ImportValue: !Sub PostRegisterLambdaArn-${Environment}

  SMSRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: !Sub "biomage-user-pool-case-insensitive-sms-role-${Environment}"
      AssumeRolePolicyDocument: |-
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "",
              "Effect": "Allow",
              "Principal": {
                "Service": "cognito-idp.amazonaws.com"
              },
              "Action": "sts:AssumeRole",
              "Condition": {
                "StringEquals": {
                  "sts:ExternalId": "92bd350f-b2ad-455a-b614-a24e63555edb"
                }
              }
            }
          ]
        }
      Path: /
      Policies:
        - PolicyName: "can-send-sms"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "sns:publish"
                Resource:
                  - '*'

  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub "biomage-user-pool-case-insensitive-${Environment}"
      AccountRecoverySetting:
        RecoveryMechanisms:
          - Name: verified_email
            Priority: 1
          - Name: verified_phone_number
            Priority: 2
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: false
        InviteMessageTemplate:
          EmailSubject: 'Your temporary password for Cellenics'
          EmailMessage: 'Thank you for signing up to Cellenics. Your username is {username} and temporary password is {####}.'
          SMSMessage: 'Your Cellenics username is {username} and temporary password is {####}.'
      AutoVerifiedAttributes:
        - email
      DeviceConfiguration:
        ChallengeRequiredOnNewDevice: true
        DeviceOnlyRememberedOnUserPrompt: true
      EmailConfiguration:
        EmailSendingAccount: COGNITO_DEFAULT
        #From: noreply@biomage.net
        ReplyToEmailAddress: hello@biomage.net
      EnabledMfas:
        - SMS_MFA
        - SOFTWARE_TOKEN_MFA
      SmsConfiguration:
        ExternalId: '92bd350f-b2ad-455a-b614-a24e63555edb'
        SnsCallerArn: !GetAtt SMSRole.Arn
      MfaConfiguration: "OPTIONAL"
      Schema:
        - Name: name
          AttributeDataType: String
          Mutable: true
          Required: true
        - Name: email
          AttributeDataType: String
          Mutable: true
          Required: true
        - Name: institution
          AttributeDataType: String
          Mutable: true
          Required: false
      SmsAuthenticationMessage: 'Your authentication code for Cellenics is {####}.'
      SmsVerificationMessage: 'Your verification code for Cellenics is {####}.'
      UsernameAttributes:
        - email
      UsernameConfiguration:
        CaseSensitive: false
      LambdaConfig:
        PostConfirmation:
          # Fn::ImportValue: !Sub PostRegisterLambdaArn-${Environment}
          !GetAtt PostRegistrationLambda.Arn

  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      UserPoolId: !Ref UserPool
      Domain: !If [isProd, "biomage-auth",!Sub "biomage-auth-${Environment}"]

  PostRegistrationTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: "alias/aws/sns"
      TopicName: !Sub "post-registration-user-access-${Environment}-default"

  PostUserRegistrationSubscription:
    Type: 'AWS::SNS::Subscription'
    Properties:
      TopicArn: !Ref PostRegistrationTopic
      Endpoint: !If [isProd, "https://api.scp.biomage.net/v2/access/post-registration",
                !Sub "https://api-default.scp-${Environment}.biomage.net/v2/access/post-registration"]
      Protocol: "https"
      DeliveryPolicy:
        healthyRetryPolicy:
          minDelayTarget: 10
          maxDelayTarget: 60
          numRetries: 56
          numNoDelayRetries: 0
          numMinDelayRetries: 2
          numMaxDelayRetries: 16
          backoffFunction: exponential
      FilterPolicy:
        type:
          - PostUserRegistration

  PostRegistrationLambdaRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Path: /
      Policies:
        - PolicyName: !Sub "can-access-dynamo-lambda-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "dynamodb:DeleteItem"
                  - "dynamodb:GetItem"
                  - "dynamodb:PutItem"
                  - "dynamodb:Scan"
                  - "dynamodb:UpdateItem"
                Resource:
                  - Fn::Sub: "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/user-access-${Environment}*"
                  - Fn::Sub: "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/invite-access-${Environment}*"
        - PolicyName: !Sub "can-create-log-group-in-cloudwatch-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                Resource:
                  - Fn::Sub: "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
        - PolicyName: !Sub "can-add-logs-in-cloudwatch-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource:
                  - Fn::Sub: "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/post-register-invite-lambda-${Environment}:*"
        - PolicyName: !Sub "can-post-to-post-registration-sns-${Environment}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - 'sns:Publish'
                Resource:
                  - Fn::Sub: "arn:aws:sns:${AWS::Region}:${AWS::AccountId}:post-registration-user-access-${Environment}-default"

  PostRegistrationLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs14.x
      Role: !Ref PostRegistrationLambdaRole
      Handler: index.handler
      Environment:
        Variables:
          POST_REGISTRATION_TOPIC_ARN: !!GetAtt PostRegistrationTopic.Arn
          CLUSTER_ENV: !Sub "${Environment}"
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');

          const region = process.env.AWS_REGION;

          const addUserPermissionV1 = async (event) => {
            const {
              userEmail,
              userId,
            } = event.request.userAttributes;

            const userAccessTableName = `user-access-${process.env.CLUSTER_ENV}`;
            const inviteAccessTableName = `invite-access-${process.env.CLUSTER_ENV}`;

            const convertToDynamoDbRecord = (data) => AWS.DynamoDB.Converter.marshall(
              data, { convertEmptyValues: false },
            );

            const db = new AWS.DynamoDB({
              region,
            });

            const params = {
              TableName: inviteAccessTableName,
              FilterExpression: '(userEmail = :userEmail)',
              ExpressionAttributeValues: {
                ...convertToDynamoDbRecord({ ':userEmail': userEmail }),
              },
            };
            const response = await db.scan(params).promise();
            if (!response.Items.length) {
              return;
            }

            // add those rows in user-access
            const experimentIds = [];
            await Promise.all(response.Items.map((item) => {
              const projectId = item.projectId.S;
              const experimentId = item.experimentId.S;
              experimentIds.push(experimentId);
              const role = item.role.S;

              const addRoleParams = {
                TableName: userAccessTableName,
                Item: {
                  userId,
                  experimentId,
                  projectId,
                  role,
                  createdDate: new Date().toISOString(),
                },
              };

              const docClient = new AWS.DynamoDB.DocumentClient({
                region,
              });

              return docClient.put(addRoleParams).promise();
            }));

            // remove rows from invite-access
            await Promise.all(experimentIds.map((id) => {
              const key = convertToDynamoDbRecord({
                experimentId: id,
                userEmail,
              });

              const dynamoParams = {
                TableName: inviteAccessTableName,
                Key: key,
              };

              return db.deleteItem(dynamoParams).send();
            }));
          };

          const createTemporarySecret = async () => {
            const smClient = await new AWS.SecretsManager({ region });

            // https://stackoverflow.com/a/8084248/1940886
            const randomString = (Math.random() + 1).toString(36).substring(2);
            await smClient.createSecret({ Name: randomString, SecretString: randomString }).promise();
          };

          const addUserPermissionV2 = async (event) => {
            const {
              userEmail,
              userId,
            } = event.request.userAttributes;

            const sns = new AWS.SNS({ region });
            // const authToken = await createTemporarySecret();

            const userInfo = {
              userId,
              userEmail,
            };

            const message = {
              type: 'PostUserRegistration',
              userInfo,
            };

            await sns.publish({
              Message: JSON.stringify(message),
              TopicArn: process.env.TOPIC_ARN,
            }, () => {}).promise();
          };

          exports.handler = async (event, context, callback) => {
            await addUserPermissionV1(event);
            await addUserPermissionV2(event);

            callback(null, event);
          };

  LoggingGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/post-invite-registration-lambda-${Environment}"
      RetentionInDays: 14